#pragma kernel Predict
#pragma kernel Integrate
#pragma kernel SolveDistanceJacobi
#pragma kernel ApplyDeltas
#pragma kernel UpdateVelocities

//Collsion
#pragma kernel BuildCollisionConstraints
#pragma kernel SolveCollisionConstraints
#pragma kernel ResetCollisionCounts


#define THREADS 256
#define MAX_COLLISIONS 8  // muss zu C# passen
#pragma target 5.0

struct Particle
{
    float3 positionP; // previous
    float3 positionX; // current
    float3 positionPredicted; // predicted (for collision handling)
    float3 velocity;
    float m;
    float w;
    float radius;
};

struct DistanceConstraint
{
    uint i;
    uint j;
    float rest;
    float compliance;
};

struct SphereCollider
{
    float3 center;
    float radius;
};

struct CollisionConstraint
{
    float3 target; 
    float3 normal;
    float radius;   
};


RWStructuredBuffer<Particle> particles;
StructuredBuffer<DistanceConstraint> constraints;
StructuredBuffer<SphereCollider> spheres;

RWStructuredBuffer<uint> deltaX;
RWStructuredBuffer<uint> deltaY;
RWStructuredBuffer<uint> deltaZ;
RWStructuredBuffer<uint> countBuf;

RWStructuredBuffer<CollisionConstraint> collisionConstraints;
RWStructuredBuffer<uint> collisionCounts; 

int particleCount;
int constraintCount;
int sphereCount;
float dt, dts, dts2;
float3 gravity;
float omega;

#define ATOMIC_ADD_FLOAT_UAV(UAV, IDX, VAL)            \
{                                                      \
    uint _old = UAV[IDX];                              \
    for (;;)                                           \
    {                                                  \
        float _oldF = asfloat(_old);                   \
        float _newF = _oldF + (VAL);                   \
        uint  _new  = asuint(_newF);                   \
        uint  _prev;                                   \
        InterlockedCompareExchange(UAV[IDX], _old, _new, _prev); \
        if (_prev == _old) break;                      \
        _old = _prev;                                  \
    }                                                  \
}


// ------------------ KERNEL 0: PREDICT ------------------ 
[numthreads(THREADS, 1, 1)]
void Predict(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    
    float3 velocity = p.velocity + gravity * dt;
    p.positionPredicted = p.positionX + velocity * dt;
    
    particles[i] = p;
}


// ------------------ KERNEL 1: INTEGRATE ------------------
[numthreads(THREADS, 1, 1)]
void Integrate(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    p.positionP = p.positionX;

    if (p.w > 0)
    {
        p.velocity += gravity * dts;
        p.positionX += p.velocity * dts;
    }

    particles[i] = p;
}

// --------- KERNEL 2: DISTANCE ---------------
[numthreads(THREADS, 1, 1)]
void SolveDistanceJacobi(uint3 tid : SV_DispatchThreadID)
{
    uint c = tid.x;
    if (c >= constraintCount)
        return;

    DistanceConstraint con = constraints[c];
    uint i = con.i;
    uint j = con.j;

    Particle pi = particles[i];
    Particle pj = particles[j];

    if (pi.w == 0 && pj.w == 0)
        return;

    float3 d = pi.positionX - pj.positionX;
    float len = length(d);
    
    if (len <= 1e-6f)
        return;

    float3 n = d / len;
    float C = len - con.rest;


    // XPBD
    float wt = pi.w + pj.w;
    float alphaT = con.compliance / dts2;
    float dLambda = -C / (wt + alphaT);

    float3 dxi = +pi.w * dLambda * n;
    float3 dxj = -pj.w * dLambda * n;

    ATOMIC_ADD_FLOAT_UAV(deltaX, i, dxi.x);
    ATOMIC_ADD_FLOAT_UAV(deltaY, i, dxi.y);
    ATOMIC_ADD_FLOAT_UAV(deltaZ, i, dxi.z);

    ATOMIC_ADD_FLOAT_UAV(deltaX, j, dxj.x);
    ATOMIC_ADD_FLOAT_UAV(deltaY, j, dxj.y);
    ATOMIC_ADD_FLOAT_UAV(deltaZ, j, dxj.z);

    InterlockedAdd(countBuf[i], 1);
    InterlockedAdd(countBuf[j], 1);
}

// ------------- KERNEL 3: APPLY DELTAS (Averaging + ω) ----------
[numthreads(THREADS, 1, 1)]
void ApplyDeltas(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x; 
    if (i >= particleCount)
        return;

    uint n = countBuf[i];
    if (n > 0)
    {
        float3 delta = float3(asfloat(deltaX[i]), asfloat(deltaY[i]), asfloat(deltaZ[i]));
        Particle p = particles[i];
        p.positionX += delta * (omega / (float) n); // Δx_i = (ω/n) * ΣΔx
        particles[i] = p;
    }

    // Reset
    deltaX[i] = 0;
    deltaY[i] = 0;
    deltaZ[i] = 0;
    countBuf[i] = 0;
}

// ------------------ KERNEL 4: UPDATE VELOCITIES ------------------
[numthreads(THREADS, 1, 1)]
void UpdateVelocities(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    if (p.w > 0)
        p.velocity = (p.positionX - p.positionP) / dts;

    particles[i] = p;
}




// ------------------ BuildCollisionConstraints (per particle) ------------------
[numthreads(THREADS, 1, 1)]
void BuildCollisionConstraints(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;
    
    if (sphereCount == 0)
        return;

    Particle p = particles[i];
    if (p.w == 0.0f)
        return;

    [loop]
    for (int s = 0; s < sphereCount; s++)
    {
        SphereCollider sc = spheres[s];

        float3 x = p.positionX;
        float3 d = x - sc.center;
        float dist = length(d);
        float r = sc.radius + p.radius;
        float pen = r - dist;

        if (pen > 0.0f)
        {
            uint idx;
            InterlockedAdd(collisionCounts[i], 1, idx);
            if (idx < MAX_COLLISIONS)
            {
                float3 n = (dist > 1e-6f) ? (d / dist) : float3(0, 1, 0);

                uint writeIndex = i * MAX_COLLISIONS + idx;

                CollisionConstraint cc;
                cc.target = sc.center + n * sc.radius;
                cc.normal = n;
                cc.radius = p.radius;

                collisionConstraints[writeIndex] = cc;
            }
        }
    }
}

// ------------------ SolveCollisionConstraints (per particle) ------------------
[numthreads(THREADS, 1, 1)]
void SolveCollisionConstraints(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    if (p.w == 0.0f)
        return;

    uint n = collisionCounts[i];
    if (n == 0)
        return;
    n = (n > MAX_COLLISIONS) ? MAX_COLLISIONS : n;

    for (uint k = 0; k < n; k++)
    {
        uint readIndex = i * MAX_COLLISIONS + k;
        CollisionConstraint cc = collisionConstraints[readIndex];

        float C = dot(p.positionX - cc.target, cc.normal) - cc.radius;
        if (C < 0.0f)
        {
            p.positionX -= cc.normal * C;
        }
    }

    particles[i] = p;
}

// ------------------ Reset Collision Counts ------------------
[numthreads(THREADS, 1, 1)]
void ResetCollisionCounts(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;
    
    collisionCounts[i] = 0;
}





