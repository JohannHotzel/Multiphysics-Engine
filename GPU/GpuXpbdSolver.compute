#pragma kernel Predict
#pragma kernel Integrate
#pragma kernel SolveDistanceJacobi
#pragma kernel ApplyDeltas
#pragma kernel UpdateVelocities

//Collsion
#pragma kernel CollideSpheres


#define THREADS 256
#pragma target 5.0

struct Particle
{
    float3 positionP; // previous
    float3 positionX; // current
    float3 positionPredicted; // predicted (for collision handling)
    float3 velocity;
    float m;
    float w;
    float radius;
};

struct DistanceConstraint
{
    uint i;
    uint j;
    float rest;
    float compliance;
};

struct SphereCollider
{
    float3 center;
    float radius;
};



RWStructuredBuffer<Particle> particles;
StructuredBuffer<DistanceConstraint> constraints;
StructuredBuffer<SphereCollider> spheres;

RWStructuredBuffer<uint> deltaX;
RWStructuredBuffer<uint> deltaY;
RWStructuredBuffer<uint> deltaZ;
RWStructuredBuffer<uint> countBuf;

int particleCount;
int constraintCount;
int sphereCount;
float dt, dts, dts2;
float3 gravity;
float omega;

#define ATOMIC_ADD_FLOAT_UAV(UAV, IDX, VAL)            \
{                                                      \
    uint _old = UAV[IDX];                              \
    for (;;)                                           \
    {                                                  \
        float _oldF = asfloat(_old);                   \
        float _newF = _oldF + (VAL);                   \
        uint  _new  = asuint(_newF);                   \
        uint  _prev;                                   \
        InterlockedCompareExchange(UAV[IDX], _old, _new, _prev); \
        if (_prev == _old) break;                      \
        _old = _prev;                                  \
    }                                                  \
}


// ------------------ KERNEL 0: PREDICT ------------------ 
[numthreads(THREADS, 1, 1)]
void Predict(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    
    float3 velocity = p.velocity + gravity * dt;
    p.positionPredicted = p.positionX + velocity * dt;
    
    particles[i] = p;
}


// ------------------ KERNEL 1: INTEGRATE ------------------
[numthreads(THREADS, 1, 1)]
void Integrate(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    p.positionP = p.positionX;

    if (p.w > 0)
    {
        p.velocity += gravity * dts;
        p.positionX += p.velocity * dts;
    }

    particles[i] = p;
}

// --------- KERNEL 2: DISTANCE ---------------
[numthreads(THREADS, 1, 1)]
void SolveDistanceJacobi(uint3 tid : SV_DispatchThreadID)
{
    uint c = tid.x;
    if (c >= constraintCount)
        return;

    DistanceConstraint con = constraints[c];
    uint i = con.i;
    uint j = con.j;

    Particle pi = particles[i];
    Particle pj = particles[j];

    if (pi.w == 0 && pj.w == 0)
        return;

    float3 d = pi.positionX - pj.positionX;
    float len = length(d);
    
    if (len <= 1e-6f)
        return;

    float3 n = d / len;
    float C = len - con.rest;


    // XPBD
    float wt = pi.w + pj.w;
    float alphaT = con.compliance / dts2;
    float dLambda = -C / (wt + alphaT);

    float3 dxi = +pi.w * dLambda * n;
    float3 dxj = -pj.w * dLambda * n;

    ATOMIC_ADD_FLOAT_UAV(deltaX, i, dxi.x);
    ATOMIC_ADD_FLOAT_UAV(deltaY, i, dxi.y);
    ATOMIC_ADD_FLOAT_UAV(deltaZ, i, dxi.z);

    ATOMIC_ADD_FLOAT_UAV(deltaX, j, dxj.x);
    ATOMIC_ADD_FLOAT_UAV(deltaY, j, dxj.y);
    ATOMIC_ADD_FLOAT_UAV(deltaZ, j, dxj.z);

    InterlockedAdd(countBuf[i], 1);
    InterlockedAdd(countBuf[j], 1);
}

// ------------- KERNEL 3: APPLY DELTAS (Averaging + ω) ----------
[numthreads(THREADS, 1, 1)]
void ApplyDeltas(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x; 
    if (i >= particleCount)
        return;

    uint n = countBuf[i];
    if (n > 0)
    {
        float3 delta = float3(asfloat(deltaX[i]), asfloat(deltaY[i]), asfloat(deltaZ[i]));
        Particle p = particles[i];
        p.positionX += delta * (omega / (float) n); // Δx_i = (ω/n) * ΣΔx
        particles[i] = p;
    }

    // Reset
    deltaX[i] = 0;
    deltaY[i] = 0;
    deltaZ[i] = 0;
    countBuf[i] = 0;
}

// ------------------ KERNEL 4: UPDATE VELOCITIES ------------------
[numthreads(THREADS, 1, 1)]
void UpdateVelocities(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    if (p.w > 0)
        p.velocity = (p.positionX - p.positionP) / dts;

    particles[i] = p;
}

// ------------------ KERNEL 5: COLLIDE SPHERES ------------------
[numthreads(THREADS, 1, 1)]
void CollideSpheres(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    if (p.w == 0.0f || sphereCount <= 0)
    {
        particles[i] = p;
        return;
    }

    float3 x = p.positionX;

    
    for (int s = 0; s < sphereCount; s++)
    {
        SphereCollider sc = spheres[s];
        float3 d = x - sc.center;
        float dist = length(d);
        float r = sc.radius + p.radius;

        if (dist < r)
        {
            float3 n = d / dist;
            float push = r - dist;

            x += n * push;
        }
    }

    p.positionX = x;
    particles[i] = p;
}