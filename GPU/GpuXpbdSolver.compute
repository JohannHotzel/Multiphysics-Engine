#pragma kernel Integrate
#pragma kernel SolveDistanceJacobi
#pragma kernel ApplyDeltas
#pragma kernel UpdateVelocities

#define THREADS 256
#pragma target 5.0

struct Particle
{
    float3 positionP; // previous
    float3 positionX; // current/predicted
    float3 velocity;
    float m;
    float w;
    float radius;
};

struct DistanceConstraint
{
    uint i;
    uint j;
    float rest;
    float compliance;
};

RWStructuredBuffer<Particle> particles;
StructuredBuffer<DistanceConstraint> constraints;

RWStructuredBuffer<uint> deltaX;
RWStructuredBuffer<uint> deltaY;
RWStructuredBuffer<uint> deltaZ;
RWStructuredBuffer<uint> countBuf;

float dt;
float dts;
float dts2;

float omega;

float3 gravity;

uint particleCount, constraintCount;

#define ATOMIC_ADD_FLOAT_UAV(UAV, IDX, VAL)            \
{                                                      \
    uint _old = UAV[IDX];                              \
    for (;;)                                           \
    {                                                  \
        float _oldF = asfloat(_old);                   \
        float _newF = _oldF + (VAL);                   \
        uint  _new  = asuint(_newF);                   \
        uint  _prev;                                   \
        InterlockedCompareExchange(UAV[IDX], _old, _new, _prev); \
        if (_prev == _old) break;                      \
        _old = _prev;                                  \
    }                                                  \
}

// ------------------ KERNEL 1: INTEGRATE ------------------
[numthreads(THREADS, 1, 1)]
void Integrate(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    p.positionP = p.positionX;

    if (p.w > 0)
    {
        p.velocity += gravity * dts;
        p.positionX += p.velocity * dts;
    }

    particles[i] = p;
}

// --------- KERNEL 2: DISTANCE ---------------
[numthreads(THREADS, 1, 1)]
void SolveDistanceJacobi(uint3 tid : SV_DispatchThreadID)
{
    uint c = tid.x;
    if (c >= constraintCount)
        return;

    DistanceConstraint con = constraints[c];
    uint i = con.i;
    uint j = con.j;

    Particle pi = particles[i];
    Particle pj = particles[j];

    if (pi.w == 0 && pj.w == 0)
        return;

    float3 d = pi.positionX - pj.positionX;
    float len = length(d);
    float3 n = (len > 1e-6) ? d / len : float3(0, 0, 0);
    float C = len - con.rest;

    // XPBD
    float wt = pi.w + pj.w;
    float alphaT = con.compliance / dts2;
    float dLambda = -C / (wt + alphaT);

    float3 dxi = +pi.w * dLambda * n;
    float3 dxj = -pj.w * dLambda * n;

    ATOMIC_ADD_FLOAT_UAV(deltaX, i, dxi.x);
    ATOMIC_ADD_FLOAT_UAV(deltaY, i, dxi.y);
    ATOMIC_ADD_FLOAT_UAV(deltaZ, i, dxi.z);

    ATOMIC_ADD_FLOAT_UAV(deltaX, j, dxj.x);
    ATOMIC_ADD_FLOAT_UAV(deltaY, j, dxj.y);
    ATOMIC_ADD_FLOAT_UAV(deltaZ, j, dxj.z);

    InterlockedAdd(countBuf[i], 1);
    InterlockedAdd(countBuf[j], 1);
}

// ------------- KERNEL 3: APPLY DELTAS (Averaging + ω) ----------
[numthreads(THREADS, 1, 1)]
void ApplyDeltas(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x; 
    if (i >= particleCount)
        return;

    uint n = countBuf[i];
    if (n > 0)
    {
        float3 delta = float3(asfloat(deltaX[i]), asfloat(deltaY[i]), asfloat(deltaZ[i]));
        Particle p = particles[i];
        p.positionX += delta * (omega / (float) n); // Δx_i = (ω/n) * ΣΔx
        particles[i] = p;
    }

    // Reset
    deltaX[i] = 0;
    deltaY[i] = 0;
    deltaZ[i] = 0;
    countBuf[i] = 0;
}

// ------------------ KERNEL 4: UPDATE VELOCITIES ------------------
[numthreads(THREADS, 1, 1)]
void UpdateVelocities(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    if (p.w > 0)
        p.velocity = (p.positionX - p.positionP) / dts;

    particles[i] = p;
}
