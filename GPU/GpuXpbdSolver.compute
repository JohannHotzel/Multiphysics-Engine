
// Core XPBD Solver
#pragma kernel Predict
#pragma kernel Integrate
#pragma kernel SolveDistanceJacobi
#pragma kernel ApplyDeltas
#pragma kernel UpdateVelocities

// Collsion
#pragma kernel BuildClothAabbs
#pragma kernel BuildSphereConstraints
#pragma kernel BuildCapsuleConstraints
#pragma kernel BuildBoxConstraints
#pragma kernel BuildMeshConstraints
#pragma kernel SolveCollisionConstraints
#pragma kernel ResetCollisionCounts

// Attachment
#pragma kernel SetAttachmentPositions

// Spacial Hashing
#pragma kernel HashClearCounts
#pragma kernel HashCountCells
#pragma kernel HashFillEntries
#pragma kernel SolveParticleCollisionsHashed


#pragma target 5.0
#include "Includes/XPBD_Types.hlsl"
#include "Includes/XPBD_CollisionChecks.hlsl"


RWStructuredBuffer<Particle> particles;
int particleCount;

StructuredBuffer<DistanceConstraint> constraints;
int constraintCount;

StructuredBuffer<ClothRange> clothRanges;
RWStructuredBuffer<Aabb> clothAabbs;

StructuredBuffer<SphereCollider> spheres;
int sphereCount;

StructuredBuffer<CapsuleCollider> capsules;
int capsuleCount;

StructuredBuffer<BoxCollider> boxes;
int boxCount;

StructuredBuffer<Triangle> meshTriangles;
StructuredBuffer<MeshRange> meshRanges;
int meshCount;

RWStructuredBuffer<uint> deltaX;
RWStructuredBuffer<uint> deltaY;
RWStructuredBuffer<uint> deltaZ;
RWStructuredBuffer<uint> countBuf;

RWStructuredBuffer<CollisionConstraint> collisionConstraints;
RWStructuredBuffer<uint> collisionCounts;


StructuredBuffer<AttachmentObject> attachmentObjects;
int attachmentObjectCount;

StructuredBuffer<AttachmentConstraint> attachmentConstraints;
int attachmentConstraintCount;

RWStructuredBuffer<uint> hashCellStarts; // size: hashTableSize + 1
RWStructuredBuffer<uint> hashCellEntries; // size: >= particleCount
int hashTableSize;
float hashSpacing;



float dt, dts, dts2;
float3 gravity;
float omega;
float vMax;
float collisionMargin;


#define ATOMIC_ADD_FLOAT_UAV(UAV, IDX, VAL)                      \
{                                                                \
    uint _old = UAV[IDX];                                        \
    for (;;)                                                     \
    {                                                            \
        float _oldF = asfloat(_old);                             \
        float _newF = _oldF + (VAL);                             \
        uint  _new  = asuint(_newF);                             \
        uint  _prev;                                             \
        InterlockedCompareExchange(UAV[IDX], _old, _new, _prev); \
        if (_prev == _old) break;                                \
        _old = _prev;                                            \
    }                                                            \
}


// ------------------ Predict Positions over whole frame (per particle) ------------------
[numthreads(THREADS, 1, 1)]
void Predict(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    
    float3 velocity = p.velocity + gravity * dt;
    p.positionPredicted = p.positionX + velocity * dt;
    
    particles[i] = p;
}


// ------------------ Integrate (per particle) ------------------
[numthreads(THREADS, 1, 1)]
void Integrate(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    p.positionP = p.positionX;

    if (p.w > 0)
    {
        p.velocity += gravity * dts;
        p.positionX += p.velocity * dts;
    }

    particles[i] = p;
}


// --------- Solve Distance Constraints (per constraint) (Jacobi) ---------
[numthreads(THREADS, 1, 1)]
void SolveDistanceJacobi(uint3 tid : SV_DispatchThreadID)
{
    uint c = tid.x;
    if (c >= constraintCount)
        return;

    DistanceConstraint con = constraints[c];
    uint i = con.i;
    uint j = con.j;

    Particle pi = particles[i];
    Particle pj = particles[j];

    if (pi.w == 0 && pj.w == 0)
        return;

    float3 d = pi.positionX - pj.positionX;
    float len = length(d);
    
    if (len <= 1e-6f)
        return;

    float3 n = d / len;
    float C = len - con.rest;


    float wt = pi.w + pj.w;
    float alphaT = con.compliance / dts2;
    float dLambda = -C / (wt + alphaT);

    float3 dxi = +pi.w * dLambda * n;
    float3 dxj = -pj.w * dLambda * n;

    ATOMIC_ADD_FLOAT_UAV(deltaX, i, dxi.x);
    ATOMIC_ADD_FLOAT_UAV(deltaY, i, dxi.y);
    ATOMIC_ADD_FLOAT_UAV(deltaZ, i, dxi.z);

    ATOMIC_ADD_FLOAT_UAV(deltaX, j, dxj.x);
    ATOMIC_ADD_FLOAT_UAV(deltaY, j, dxj.y);
    ATOMIC_ADD_FLOAT_UAV(deltaZ, j, dxj.z);

    InterlockedAdd(countBuf[i], 1);
    InterlockedAdd(countBuf[j], 1);
}


// ------------- Apply Deltas (per particle) (Averaging + ω) ----------------
[numthreads(THREADS, 1, 1)]
void ApplyDeltas(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    uint n = countBuf[i];
    if (n > 0)
    {
        float3 delta = float3(asfloat(deltaX[i]), asfloat(deltaY[i]), asfloat(deltaZ[i]));
        Particle p = particles[i];
        p.positionX += delta * (omega / (float) n); // Δx_i = (ω/n) * ΣΔx
        particles[i] = p;
    }

    // Reset
    deltaX[i] = 0;
    deltaY[i] = 0;
    deltaZ[i] = 0;
    countBuf[i] = 0;
}


// ------------------ Update Velocities (per particle) ------------------
[numthreads(THREADS, 1, 1)]
void UpdateVelocities(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    if (p.w > 0)
        p.velocity = (p.positionX - p.positionP) / dts;

    particles[i] = p;
}


// ------------------ BuildClothAabbs (per cloth) ------------------
[numthreads(1, 1, 1)]
void BuildClothAabbs(uint3 id : SV_DispatchThreadID)
{
    uint c = id.x;

    ClothRange r = clothRanges[c];
    uint start = r.start;
    uint count = r.count;

    if (count == 0)
    {
        Aabb a;
        a.mn = float3(0, 0, 0);
        a.mx = float3(0, 0, 0);
        clothAabbs[c] = a;
        return;
    }

    float3 mn = float3(+3.4e38f, +3.4e38f, +3.4e38f);
    float3 mx = float3(-3.4e38f, -3.4e38f, -3.4e38f);

    [loop]
    for (uint i = 0; i < count; i++)
    {
        float3 p = particles[start + i].positionPredicted;
        mn = min(mn, p);
        mx = max(mx, p);
    }

    Aabb outAabb;
    outAabb.mn = mn;
    outAabb.mx = mx;
    clothAabbs[c] = outAabb;
}


// ------------------ BuildCollisionConstraints (per particle) ------------------
[numthreads(THREADS, 1, 1)]
void BuildSphereConstraints(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    if (p.w == 0.0f)
        return;

    float3 x = p.positionX;
    float pr = p.radius;

    [branch]
    if (sphereCount == 0)
        return;

    [loop]
    for (int s = 0; s < sphereCount; s++)
    {
        float3 target, n;
        if (CollideSphere(x, pr, spheres[s], target, n))
        {
            uint idx;
            InterlockedAdd(collisionCounts[i], 1, idx);
            if (idx < MAX_COLLISIONS)
            {
                uint writeIndex = i * MAX_COLLISIONS + idx;
                CollisionConstraint cc;
                cc.target = target;
                cc.normal = n;
                cc.radius = pr;
                collisionConstraints[writeIndex] = cc;
            }
        }
    }
}

[numthreads(THREADS, 1, 1)]
void BuildCapsuleConstraints(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    if (p.w == 0.0f)
        return;

    float3 x = p.positionX;
    float pr = p.radius;

    [branch]
    if (capsuleCount == 0)
        return;

    [loop]
    for (int c = 0; c < capsuleCount; c++)
    {
        float3 target, n;
        if (CollideCapsule(x, pr, capsules[c], target, n))
        {
            uint idx;
            InterlockedAdd(collisionCounts[i], 1, idx);
            if (idx < MAX_COLLISIONS)
            {
                uint writeIndex = i * MAX_COLLISIONS + idx;
                CollisionConstraint cc;
                cc.target = target;
                cc.normal = n;
                cc.radius = pr;
                collisionConstraints[writeIndex] = cc;
            }
        }
    }
}

[numthreads(THREADS, 1, 1)]
void BuildBoxConstraints(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    if (p.w == 0.0f)
        return;

    float3 x = p.positionX;
    float pr = p.radius;

    [branch]
    if (boxCount == 0)
        return;

    [loop]
    for (int b = 0; b < boxCount; b++)
    {
        float3 target, n;
        if (CollideBox(x, pr, boxes[b], target, n))
        {
            uint idx;
            InterlockedAdd(collisionCounts[i], 1, idx);
            if (idx < MAX_COLLISIONS)
            {
                uint writeIndex = i * MAX_COLLISIONS + idx;
                CollisionConstraint cc;
                cc.target = target;
                cc.normal = n;
                cc.radius = pr;
                collisionConstraints[writeIndex] = cc;
            }
        }
    }
}

[numthreads(THREADS, 1, 1)]
void BuildMeshConstraints(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    if (p.w == 0.0f)
        return;

    if (meshCount == 0)
        return;

    float3 x = p.positionX;
    float pr = p.radius;

    [loop]
    for (int m = 0; m < meshCount; m++)
    {
        MeshRange r = meshRanges[m];
        uint start = r.start;
        uint count = r.count;

        [loop]
        for (uint t = 0; t < count; t++)
        {
            Triangle tri = meshTriangles[start + t];

            float3 target, n;
            if (CollideTriangle(x, pr, tri, target, n))
            {
                uint idx;
                InterlockedAdd(collisionCounts[i], 1, idx);
                if (idx < MAX_COLLISIONS)
                {
                    uint writeIndex = i * MAX_COLLISIONS + idx;
                    CollisionConstraint cc;
                    cc.target = target;
                    cc.normal = n;
                    cc.radius = pr;
                    collisionConstraints[writeIndex] = cc;
                }
            }
        }
    }
}


// ------------------ SolveCollisionConstraints (per particle) ------------------
[numthreads(THREADS, 1, 1)]
void SolveCollisionConstraints(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;

    Particle p = particles[i];
    if (p.w == 0.0f)
        return;

    uint n = collisionCounts[i];
    if (n == 0)
        return;
    n = (n > MAX_COLLISIONS) ? MAX_COLLISIONS : n;

    for (uint k = 0; k < n; k++)
    {
        uint readIndex = i * MAX_COLLISIONS + k;
        CollisionConstraint cc = collisionConstraints[readIndex];

        float C = dot(p.positionX - cc.target, cc.normal) - cc.radius;
        
        if (C < 0.0f)
        {
            //Bias to clamp maximum velocity
            float d0 = -C;
            float bias = (vMax > 0.0f) ? max(d0 - vMax * dts, 0.0f) : 0.0f;
            float phi = C + bias;

            if (phi < 0.0f)
            {
                p.positionX -= cc.normal * phi;
            }
        }
    }

    particles[i] = p;
}


// ------------------ SolveAttachmentConstraints (per constraint) ------------------
[numthreads(THREADS, 1, 1)]
void SetAttachmentPositions(uint3 tid : SV_DispatchThreadID)
{
    uint c = tid.x;
    if (c >= attachmentConstraintCount)
        return;

    AttachmentConstraint ac = attachmentConstraints[c];
    if (ac.particle >= particleCount)
        return;

    uint i = ac.particle;

    float3 target = mul(attachmentObjects[ac.objectIndex].world, float4(ac.localPoint, 1)).xyz;

    Particle p = particles[i];
    p.positionX = target;
    p.positionP = target;
    p.positionPredicted = target;

    particles[i] = p;
}


// ------------------ Reset Collision Counts ------------------
[numthreads(THREADS, 1, 1)]
void ResetCollisionCounts(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;
    
    collisionCounts[i] = 0;
}


// ------------------ Spatial Hashing -------------------
int3 HashGridCoord(float3 p, float spacing)
{
    return (int3) floor(p / spacing);
}

uint HashHashCoord(int3 c, uint tableSize)
{
    int h = (c.x * 92837111) ^ (c.y * 689287499) ^ (c.z * 283923481);
    if (h < 0)
        h = -h;
    return (uint) (h % (int) tableSize);
}

[numthreads(THREADS, 1, 1)]
void HashClearCounts(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i <= hashTableSize)
    {
        hashCellStarts[i] = 0;
    }
}

[numthreads(THREADS, 1, 1)]
void HashCountCells(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;
    
    float3 p = particles[i].positionX;
    int3 gc = HashGridCoord(p, hashSpacing);
    uint h = HashHashCoord(gc, hashTableSize);
    InterlockedAdd(hashCellStarts[h], 1);
}

[numthreads(THREADS, 1, 1)]
void HashFillEntries(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;
    
    float3 p = particles[i].positionX;
    int3 gc = HashGridCoord(p, hashSpacing);
    uint h = HashHashCoord(gc, hashTableSize);
    uint oldEnd;
    InterlockedAdd(hashCellStarts[h], (uint) (-1), oldEnd);
    hashCellEntries[oldEnd - 1] = i;
}

[numthreads(THREADS, 1, 1)]
void SolveParticleCollisionsHashed(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    
    if (i >= particleCount)
        return;
    
    Particle pi = particles[i];
    
    if (pi.w == 0.0f)
        return;

    float3 xi = pi.positionX;
    float ri = pi.radius;
    int3 gc = HashGridCoord(xi, hashSpacing);


    for (int dx = -1; dx <= 1; ++dx)
        for (int dy = -1; dy <= 1; ++dy)
            for (int dz = -1; dz <= 1; ++dz)
            {
                uint h = HashHashCoord(gc + int3(dx, dy, dz), hashTableSize);
                uint start = hashCellStarts[h];
                uint end = hashCellStarts[h + 1];

                for (uint k = start; k < end; ++k)
                {
                    uint j = hashCellEntries[k];
                    
                    if (j <= i)
                        continue;
                    
                    Particle pj = particles[j];
                    
                    if (pj.w == 0.0f)
                        continue;

                    float3 d = xi - pj.positionX;
                    float dist2 = dot(d, d);
                    float minDist = ri + pj.radius + collisionMargin;
                    float minDist2 = minDist * minDist;
                    if (dist2 >= minDist2)
                        continue;

                    float dist = sqrt(max(dist2, 1e-12));
                    float3 n = (dist > 1e-6) ? (d / dist) : float3(1, 0, 0);
                    float pen = minDist - dist;

                    float wi = pi.w, wj = pj.w, wt = wi + wj;
                    if (wt <= 0)
                        continue;
                    float3 dxi = (wi / wt) * pen * 0.5f * n;
                    float3 dxj = -(wj / wt) * pen * 0.5f * n;

                    ATOMIC_ADD_FLOAT_UAV(deltaX, i, dxi.x);
                    ATOMIC_ADD_FLOAT_UAV(deltaY, i, dxi.y);
                    ATOMIC_ADD_FLOAT_UAV(deltaZ, i, dxi.z);
                    InterlockedAdd(countBuf[i], 1);

                    ATOMIC_ADD_FLOAT_UAV(deltaX, j, dxj.x);
                    ATOMIC_ADD_FLOAT_UAV(deltaY, j, dxj.y);
                    ATOMIC_ADD_FLOAT_UAV(deltaZ, j, dxj.z);
                    InterlockedAdd(countBuf[j], 1);
                }
            }
}

