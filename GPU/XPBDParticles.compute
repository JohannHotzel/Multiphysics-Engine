#pragma kernel Integrate
#pragma kernel SolveConstraints
#pragma kernel UpdateVelocities

#define THREADS 256

struct Particle
{
    float3 positionP; // previous
    float3 positionX; // current/predicted
    float3 velocity;
    float m;
    float w;
    float radius;
};

RWStructuredBuffer<Particle> _Particles;

float3 _BoundsMin;
float3 _BoundsMax;
float _DeltaTime;
float _Gravity;
uint _ParticleCount;


// ------------------ KERNEL 1: INTEGRATE ------------------
[numthreads(THREADS, 1, 1)]
void Integrate(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _ParticleCount)
        return;

    Particle p = _Particles[i];
    if (p.w == 0)
        return; // static

    p.positionP = p.positionX;

    // gravity
    p.velocity.y += (-_Gravity) * _DeltaTime;

    // predict
    p.positionX += p.velocity * _DeltaTime;

    _Particles[i] = p;
}

// ------------------ KERNEL 2: SOLVE CONSTRAINTS ------------------
[numthreads(THREADS, 1, 1)]
void SolveConstraints(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _ParticleCount)
        return;

    Particle p = _Particles[i];

    // simple AABB bounds
    if (p.positionX.y - p.radius < _BoundsMin.y)
        p.positionX.y = _BoundsMin.y + p.radius;
    if (p.positionX.y + p.radius > _BoundsMax.y)
        p.positionX.y = _BoundsMax.y - p.radius;

    if (p.positionX.x - p.radius < _BoundsMin.x)
        p.positionX.x = _BoundsMin.x + p.radius;
    if (p.positionX.x + p.radius > _BoundsMax.x)
        p.positionX.x = _BoundsMax.x - p.radius;

    if (p.positionX.z - p.radius < _BoundsMin.z)
        p.positionX.z = _BoundsMin.z + p.radius;
    if (p.positionX.z + p.radius > _BoundsMax.z)
        p.positionX.z = _BoundsMax.z - p.radius;

    _Particles[i] = p;
}


// ------------------ KERNEL 3: UPDATE VELOCITIES ------------------
[numthreads(THREADS, 1, 1)]
void UpdateVelocities(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _ParticleCount)
        return;

    Particle p = _Particles[i];
    if (p.w == 0)
        return;

    p.velocity = (p.positionX - p.positionP) / _DeltaTime;

    _Particles[i] = p;
}